# <span id="module-3-tempstore">3. Persistance temporaire : In-Memory (CRUD articles)</span>


## <span id="3.1">3.1 Objectif du module</span>

Créer un micro-service REST complet pour la gestion d’articles sans base de données.
Ce CRUD utilise uniquement :

* un tableau en mémoire (`In-Memory`)
* des identifiants générés automatiquement (`uuid`)
* une **validation manuelle minimale**
* des **routes REST** respectant les conventions HTTP (`GET`, `POST`, `PUT`, `DELETE`)



## <span id="3.2">3.2 Préparer les fichiers</span>

### Fichier `src/types/article.ts` – Définition du type Article

```ts
export type Article = {
  id: string
  title: string
  content: string
  createdAt: string
}
```



### Fichier `src/lib/data.ts` – Stockage temporaire en mémoire

```ts
import { Article } from '@/types/article'

export const articles: Article[] = []
```



### Fichier `src/lib/utils.ts` – Génération d’identifiants uniques

Installer la dépendance :

```bash
npm install uuid
```

Code du fichier :

```ts
import { v4 as uuidv4 } from 'uuid'

export function generateId() {
  return uuidv4()
}
```



## <span id="3.3">3.3 Route GET – Liste de tous les articles</span>

Fichier : `src/app/api/articles/route.ts`

```ts
import { NextResponse } from 'next/server'
import { articles } from '@/lib/data'

export async function GET() {
  return NextResponse.json(articles)
}
```

Testez dans votre navigateur :

```
http://localhost:3000/api/articles
```



## <span id="3.4">3.4 Route POST – Création d’un article</span>

Dans le même fichier `route.ts` :

```ts
import { generateId } from '@/lib/utils'

export async function POST(req: Request) {
  const body = await req.json()

  if (!body.title || !body.content) {
    return NextResponse.json({ error: 'Missing fields' }, { status: 400 })
  }

  const newArticle = {
    id: generateId(),
    title: body.title,
    content: body.content,
    createdAt: new Date().toISOString(),
  }

  articles.push(newArticle)

  return NextResponse.json(newArticle, { status: 201 })
}
```



### Test avec `curl`

```bash
curl -X POST http://localhost:3000/api/articles \
  -H "Content-Type: application/json" \
  -d '{"title":"Test", "content":"Ceci est un article."}'
```



## <span id="3.5">3.5 Routes dynamiques : GET, PUT, DELETE par `id`</span>

Fichier : `src/app/api/articles/[id]/route.ts`



### Route GET – Lire un seul article

```ts
import { articles } from '@/lib/data'
import { NextResponse } from 'next/server'

export async function GET(_: Request, context: { params: { id: string } }) {
  const article = articles.find((a) => a.id === context.params.id)

  if (!article) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  return NextResponse.json(article)
}
```



### Route PUT – Mettre à jour un article

```ts
export async function PUT(req: Request, context: { params: { id: string } }) {
  const index = articles.findIndex((a) => a.id === context.params.id)

  if (index === -1) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  const body = await req.json()

  if (!body.title || !body.content) {
    return NextResponse.json({ error: 'Invalid payload' }, { status: 400 })
  }

  articles[index] = {
    ...articles[index],
    title: body.title,
    content: body.content,
  }

  return NextResponse.json(articles[index])
}
```



### Route DELETE – Supprimer un article

```ts
export async function DELETE(_: Request, context: { params: { id: string } }) {
  const index = articles.findIndex((a) => a.id === context.params.id)

  if (index === -1) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  const deleted = articles.splice(index, 1)

  return NextResponse.json(deleted[0])
}
```



## <span id="3.6">3.6 Validation manuelle minimale</span>

À ce stade, nous n’utilisons **aucune librairie de validation externe**.
Seules des instructions simples comme :

```ts
if (!body.title || !body.content) { ... }
```

sont utilisées pour garantir un minimum de cohérence dans les données.

> Nous renforcerons cela avec `zod` dans le module suivant.



## <span id="3.7">3.7 Tests à effectuer</span>

* [x] Créer un article (`POST /api/articles`)
* [x] Lire tous les articles (`GET /api/articles`)
* [x] Lire un seul article (`GET /api/articles/:id`)
* [x] Modifier un article (`PUT /api/articles/:id`)
* [x] Supprimer un article (`DELETE /api/articles/:id`)



## <span id="3.8">3.8 Commit attendu</span>

```bash
git add .
git commit -m "feat: complete CRUD for articles with in-memory store"
```



## <span id="3.9">3.9 Prochaine étape</span>

Dans le **Module 4**, nous allons :

* intégrer une base de données réelle : **PostgreSQL**
* utiliser **Prisma** comme ORM
* remplacer le tableau `In-Memory` par une table réelle
* commencer à construire des validations avancées avec `zod`


<br/>

# Annexe 1 - Résumé des codes à ajouter



# <span id="module-3-tempstore">3. Persistance temporaire : In-Memory (CRUD articles)</span>



## <span id="3.1">3.1 Objectif du module</span>

Créer un micro-service REST complet pour la gestion d’articles sans base de données.
Ce module implémente :

* un tableau en mémoire (`In-Memory`)
* des identifiants générés automatiquement avec `uuid`
* une validation manuelle minimale
* des routes REST conformes aux standards HTTP (`GET`, `POST`, `PUT`, `DELETE`)



## <span id="3.2">3.2 Préparer les fichiers</span>

### Organisation visuelle du projet

```
my-api-project/
├── src/
│   ├── app/
│   │   └── api/
│   │       └── articles/
│   │           ├── route.ts              ← pour GET (tous) et POST
│   │           └── [id]/                 ← dossier dynamique
│   │               └── route.ts          ← pour GET, PUT, DELETE par ID
│   ├── lib/
│   │   ├── data.ts                       ← tableau d'articles en mémoire
│   │   └── utils.ts                      ← génération UUID
│   └── types/
│       └── article.ts                    ← structure TypeScript d’un article
├── package.json
├── tsconfig.json
├── .prettierrc.json
```



### Fichier `src/types/article.ts` – Définition du type Article

```ts
export type Article = {
  id: string
  title: string
  content: string
  createdAt: string
}
```



### Fichier `src/lib/data.ts` – Stockage temporaire en mémoire

```ts
import { Article } from '@/types/article'

export const articles: Article[] = []
```


### Fichier `src/lib/utils.ts` – Génération d’identifiants uniques

Installez la dépendance :

```bash
npm install uuid
```

Code du fichier :

```ts
import { v4 as uuidv4 } from 'uuid'

export function generateId() {
  return uuidv4()
}
```



## <span id="3.3">3.3 Route GET – Liste de tous les articles</span>

Fichier : `src/app/api/articles/route.ts`

```ts
import { NextResponse } from 'next/server'
import { articles } from '@/lib/data'

export async function GET() {
  return NextResponse.json(articles)
}
```

Testez dans votre navigateur :

```
http://localhost:3000/api/articles
```


## <span id="3.4">3.4 Route POST – Création d’un article</span>

Toujours dans `src/app/api/articles/route.ts` :

```ts
import { generateId } from '@/lib/utils'

export async function POST(req: Request) {
  const body = await req.json()

  if (!body.title || !body.content) {
    return NextResponse.json({ error: 'Missing fields' }, { status: 400 })
  }

  const newArticle = {
    id: generateId(),
    title: body.title,
    content: body.content,
    createdAt: new Date().toISOString(),
  }

  articles.push(newArticle)

  return NextResponse.json(newArticle, { status: 201 })
}
```


### Test avec `curl`

```bash
curl -X POST http://localhost:3000/api/articles \
  -H "Content-Type: application/json" \
  -d '{"title":"Test", "content":"Ceci est un article."}'
```



## <span id="3.5">3.5 Routes dynamiques : GET, PUT, DELETE par `id`</span>

Fichier : `src/app/api/articles/[id]/route.ts`



### Route GET – Lire un seul article

```ts
import { articles } from '@/lib/data'
import { NextResponse } from 'next/server'

export async function GET(_: Request, context: { params: { id: string } }) {
  const article = articles.find((a) => a.id === context.params.id)

  if (!article) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  return NextResponse.json(article)
}
```



### Route PUT – Mettre à jour un article

```ts
export async function PUT(req: Request, context: { params: { id: string } }) {
  const index = articles.findIndex((a) => a.id === context.params.id)

  if (index === -1) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  const body = await req.json()

  if (!body.title || !body.content) {
    return NextResponse.json({ error: 'Invalid payload' }, { status: 400 })
  }

  articles[index] = {
    ...articles[index],
    title: body.title,
    content: body.content,
  }

  return NextResponse.json(articles[index])
}
```



### Route DELETE – Supprimer un article

```ts
export async function DELETE(_: Request, context: { params: { id: string } }) {
  const index = articles.findIndex((a) => a.id === context.params.id)

  if (index === -1) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  const deleted = articles.splice(index, 1)

  return NextResponse.json(deleted[0])
}
```



## <span id="3.6">3.6 Validation manuelle minimale</span>

Aucune librairie externe n’est utilisée à ce stade.

Exemple de validation utilisée :

```ts
if (!body.title || !body.content) {
  return NextResponse.json({ error: 'Missing fields' }, { status: 400 })
}
```

Cela assure que les données obligatoires (`title`, `content`) sont bien présentes.

> Une validation plus stricte sera ajoutée avec `zod` dans le Module 5.


## <span id="3.7">3.7 Tests à effectuer</span>

|  Méthode | URL                 | Attendu                        |
| -------: | ------------------- | ------------------------------ |
|   `POST` | `/api/articles`     | Crée un nouvel article         |
|    `GET` | `/api/articles`     | Liste tous les articles        |
|    `GET` | `/api/articles/:id` | Récupère un article spécifique |
|    `PUT` | `/api/articles/:id` | Met à jour un article existant |
| `DELETE` | `/api/articles/:id` | Supprime un article            |

Checklist :

* [x] Créer un article
* [x] Lire tous les articles
* [x] Lire un seul article
* [x] Modifier un article
* [x] Supprimer un article



## <span id="3.8">3.8 Commit attendu</span>

```bash
git add .
git commit -m "feat: complete CRUD for articles with in-memory store"
```


## <span id="3.9">3.9 Prochaine étape</span>

Dans le **Module 4**, nous allons :

* Remplacer le tableau en mémoire par une base **PostgreSQL**
* Utiliser **Prisma** pour modéliser les données
* Connecter Prisma à une base distante (Neon)
* Implémenter le même CRUD, mais avec persistance réelle


