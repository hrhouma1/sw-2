# <span id="module-3-tempstore">3. Persistance temporaire : In-Memory (CRUD articles)</span>


## <span id="3.1">3.1 Objectif du module</span>

Cr√©er un micro-service REST complet pour la gestion d‚Äôarticles sans base de donn√©es.
Ce CRUD utilise uniquement :

* un tableau en m√©moire (`In-Memory`)
* des identifiants g√©n√©r√©s automatiquement (`uuid`)
* une **validation manuelle minimale**
* des **routes REST** respectant les conventions HTTP (`GET`, `POST`, `PUT`, `DELETE`)



## <span id="3.2">3.2 Pr√©parer les fichiers</span>

### Fichier `src/types/article.ts` ‚Äì D√©finition du type Article

```ts
export type Article = {
  id: string
  title: string
  content: string
  createdAt: string
}
```



### Fichier `src/lib/data.ts` ‚Äì Stockage temporaire en m√©moire

```ts
import { Article } from '@/types/article'

export const articles: Article[] = []
```



### Fichier `src/lib/utils.ts` ‚Äì G√©n√©ration d‚Äôidentifiants uniques

Installer la d√©pendance :

```bash
npm install uuid
```

Code du fichier :

```ts
import { v4 as uuidv4 } from 'uuid'

export function generateId() {
  return uuidv4()
}
```



## <span id="3.3">3.3 Route GET ‚Äì Liste de tous les articles</span>

Fichier : `src/app/api/articles/route.ts`

```ts
import { NextResponse } from 'next/server'
import { articles } from '@/lib/data'

export async function GET() {
  return NextResponse.json(articles)
}
```

Testez dans votre navigateur :

```
http://localhost:3000/api/articles
```



## <span id="3.4">3.4 Route POST ‚Äì Cr√©ation d‚Äôun article</span>

Dans le m√™me fichier `route.ts` :

```ts
import { generateId } from '@/lib/utils'

export async function POST(req: Request) {
  const body = await req.json()

  if (!body.title || !body.content) {
    return NextResponse.json({ error: 'Missing fields' }, { status: 400 })
  }

  const newArticle = {
    id: generateId(),
    title: body.title,
    content: body.content,
    createdAt: new Date().toISOString(),
  }

  articles.push(newArticle)

  return NextResponse.json(newArticle, { status: 201 })
}
```



#### 3.4.1. Test avec `curl` et cmd

```bash
curl -X POST http://localhost:3000/api/articles -H "Content-Type: application/json" -d "{\"title\":\"Test\", \"content\":\"Ceci est un article.\"}"
```

#### 3.4.2.  Test avec powershell et Invoke-RestMethod

```bash
$body = @{
    title = "Test"
    content = "Ceci est un article."
} | ConvertTo-Json

Invoke-RestMethod -Uri "http://localhost:3000/api/articles" -Method POST -ContentType "application/json" -Body $body
```

#### 3.4.3. Exercice : Testez avec Postman


# Proc√©dure pour tester avec Postman

#### 3.4.3.1. **Ouvrir Postman**
- Lancez l'application Postman
- Si vous n'avez pas Postman, t√©l√©chargez-le depuis https://www.postman.com/downloads/

#### 3.4.3.2. **Cr√©er une nouvelle requ√™te**
- Cliquez sur le bouton **"New"** ou **"+"** pour cr√©er une nouvelle requ√™te
- Ou utilisez le raccourci `Ctrl+N`

#### 3.4.3.3. **Configurer la requ√™te POST**

### **M√©thode HTTP:**
- S√©lectionnez **POST** dans le menu d√©roulant (√† gauche de l'URL)

### **URL:**
```
http://localhost:3000/api/articles
```

### **Headers:**
- Cliquez sur l'onglet **"Headers"**
- Ajoutez un nouveau header :
  - **Key:** `Content-Type`
  - **Value:** `application/json`

### **Body:**
- Cliquez sur l'onglet **"Body"**
- S√©lectionnez **"raw"**
- Dans le menu d√©roulant √† droite, s√©lectionnez **"JSON"**
- Collez ce JSON dans la zone de texte :

```json
{
  "title": "Test Article",
  "content": "Ceci est un article de test cr√©√© avec Postman."
}
```

#### 3.4.3.4. **Envoyer la requ√™te**
- Cliquez sur le bouton **"Send"** (bleu)
- Vous devriez voir la r√©ponse dans la section du bas

#### 3.4.3.5. **V√©rifier la r√©ponse**
Vous devriez recevoir :
- **Status:** `200 OK` ou `201 Created`
- **Response body:** Les donn√©es de l'article cr√©√©

#### 3.4.3.6. **Tests suppl√©mentaires**

### **Test GET (r√©cup√©rer tous les articles):**
- Cr√©ez une nouvelle requ√™te
- M√©thode: **GET**
- URL: `http://localhost:3000/api/articles`
- Pas besoin de headers ou body
- Cliquez **Send**

### **Test avec des donn√©es invalides:**
- Cr√©ez une requ√™te POST avec un JSON invalide pour tester la gestion d'erreurs
- Par exemple, sans le champ "title" requis :
```json
{
  "content": "Article sans titre"
}
```

#### 3.4.3.7. **Organiser vos tests**
- Vous pouvez sauvegarder vos requ√™tes dans une **Collection**
- Cliquez sur **"Save"** et cr√©ez une collection "API Articles Tests"
- Ajoutez toutes vos requ√™tes de test dans cette collection

## Screenshot des param√®tres Postman:
```
Method: POST
URL: http://localhost:3000/api/articles

Headers tab:
Key: Content-Type    Value: application/json

Body tab:
‚óã none  ‚óã form-data  ‚óã x-www-form-urlencoded  ‚óè raw  ‚óã binary
[JSON dropdown selected]

{
  "title": "Test Article",
  "content": "Ceci est un article de test cr√©√© avec Postman."
}
```








<br /¬≠>











## <span id="3.5">3.5 Routes dynamiques : GET, PUT, DELETE par `id`</span>

Fichier : `src/app/api/articles/[id]/route.ts`



### Route GET ‚Äì Lire un seul article

```ts
import { articles } from '@/lib/data'
import { NextResponse } from 'next/server'

export async function GET(_: Request, context: { params: { id: string } }) {
  const article = articles.find((a) => a.id === context.params.id)

  if (!article) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  return NextResponse.json(article)
}
```



### Route PUT ‚Äì Mettre √† jour un article

```ts
export async function PUT(req: Request, context: { params: { id: string } }) {
  const index = articles.findIndex((a) => a.id === context.params.id)

  if (index === -1) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  const body = await req.json()

  if (!body.title || !body.content) {
    return NextResponse.json({ error: 'Invalid payload' }, { status: 400 })
  }

  articles[index] = {
    ...articles[index],
    title: body.title,
    content: body.content,
  }

  return NextResponse.json(articles[index])
}
```



### Route DELETE ‚Äì Supprimer un article

```ts
export async function DELETE(_: Request, context: { params: { id: string } }) {
  const index = articles.findIndex((a) => a.id === context.params.id)

  if (index === -1) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  const deleted = articles.splice(index, 1)

  return NextResponse.json(deleted[0])
}
```



## <span id="3.6">3.6 Validation manuelle minimale</span>

√Ä ce stade, nous n‚Äôutilisons **aucune librairie de validation externe**.
Seules des instructions simples comme :

```ts
if (!body.title || !body.content) { ... }
```

sont utilis√©es pour garantir un minimum de coh√©rence dans les donn√©es.

> Nous renforcerons cela avec `zod` dans le module suivant.



## <span id="3.7">3.7 Tests √† effectuer</span>

* [x] Cr√©er un article (`POST /api/articles`)
* [x] Lire tous les articles (`GET /api/articles`)
* [x] Lire un seul article (`GET /api/articles/:id`)
* [x] Modifier un article (`PUT /api/articles/:id`)
* [x] Supprimer un article (`DELETE /api/articles/:id`)



## <span id="3.6">3.6 R√©sum√©  </span>


![image](https://github.com/user-attachments/assets/e9c0dd0f-d9af-4462-a17c-3e9ed2b72cdb)



```
src/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îî‚îÄ‚îÄ api/articles/
‚îÇ       ‚îî‚îÄ‚îÄ [id]/
‚îÇ           ‚îî‚îÄ‚îÄ route.ts
‚îÇ       ‚îî‚îÄ‚îÄ route.ts
‚îú‚îÄ‚îÄ favicon.ico
‚îú‚îÄ‚îÄ layout.tsx
‚îú‚îÄ‚îÄ page.module.css
‚îú‚îÄ‚îÄ lib/
‚îú‚îÄ‚îÄ types/
‚îú‚îÄ‚îÄ test-lint.ts
```


## Repr√©sentation en ascii

```powershell
import { articles } from '@/lib/data'
import { NextResponse } from 'next/server'

// Route GET ‚Äì Lire un seul article
export async function GET(_: Request, context: { params: { id: string } }) {
  const article = articles.find((a) => a.id === context.params.id)

  if (!article) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  return NextResponse.json(article)
}

// Route PUT ‚Äì Mettre √† jour un article
export async function PUT(req: Request, context: { params: { id: string } }) {
  const index = articles.findIndex((a) => a.id === context.params.id)

  if (index === -1) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  const body = await req.json()

  if (!body.title || !body.content) {
    return NextResponse.json({ error: 'Invalid payload' }, { status: 400 })
  }

  articles[index] = {
    ...articles[index],
    title: body.title,
    content: body.content,
  }

  return NextResponse.json(articles[index])
}

// Route DELETE ‚Äì Supprimer un article
export async function DELETE(_: Request, context: { params: { id: string } }) {
  const index = articles.findIndex((a) => a.id === context.params.id)

  if (index === -1) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  const deleted = articles.splice(index, 1)

  return NextResponse.json(deleted[0])
} 
```

# **Suite de tests CRUD avec Invoke-RestMethod - √Ä copier dans l'ordre**

## **1. Cr√©er le premier article (POST)**
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles" -Method POST -ContentType "application/json" -Body '{"title":"Premier Article", "content":"Contenu du premier article de test."}'
```

## **2. Cr√©er le deuxi√®me article (POST)**
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles" -Method POST -ContentType "application/json" -Body '{"title":"Deuxi√®me Article", "content":"Contenu du deuxi√®me article de test."}'
```

## **3. Cr√©er le troisi√®me article (POST)**
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles" -Method POST -ContentType "application/json" -Body '{"title":"Article √† supprimer", "content":"Cet article sera supprim√© plus tard."}'
```

## **4. Lire tous les articles (GET)**
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles" -Method GET
```

## **5. Lire le premier article par ID (GET)**
*Remplacez `ARTICLE_ID_1` par l'ID du premier article retourn√©*
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles/ARTICLE_ID_1" -Method GET
```

## **6. Lire le deuxi√®me article par ID (GET)**
*Remplacez `ARTICLE_ID_2` par l'ID du deuxi√®me article retourn√©*
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles/ARTICLE_ID_2" -Method GET
```

## **7. Modifier le premier article (PUT)**
*Remplacez `ARTICLE_ID_1` par l'ID du premier article*
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles/ARTICLE_ID_1" -Method PUT -ContentType "application/json" -Body '{"title":"Premier Article MODIFI√â", "content":"Contenu modifi√© du premier article."}'
```

## **8. V√©rifier la modification (GET)**
*Remplacez `ARTICLE_ID_1` par l'ID du premier article*
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles/ARTICLE_ID_1" -Method GET
```

## **9. Supprimer le troisi√®me article (DELETE)**
*Remplacez `ARTICLE_ID_3` par l'ID du troisi√®me article*
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles/ARTICLE_ID_3" -Method DELETE
```

## **10. V√©rifier la suppression - Lire tous les articles (GET)**
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles" -Method GET
```

## **11. Essayer de lire l'article supprim√© (doit retourner 404)**
*Remplacez `ARTICLE_ID_3` par l'ID de l'article supprim√©*
```powershell
try { Invoke-RestMethod -Uri "http://localhost:3000/api/articles/ARTICLE_ID_3" -Method GET } catch { Write-Host "Erreur 404 attendue: $($_.Exception.Message)" }
```

## **12. Test d'erreur - Cr√©er un article invalide (POST)**
```powershell
try { Invoke-RestMethod -Uri "http://localhost:3000/api/articles" -Method POST -ContentType "application/json" -Body '{"title":""}' } catch { Write-Host "Erreur 400 attendue: $($_.Exception.Message)" }
```

## **13. Test d'erreur - Modifier un article inexistant (PUT)**
```powershell
try { Invoke-RestMethod -Uri "http://localhost:3000/api/articles/inexistant" -Method PUT -ContentType "application/json" -Body '{"title":"Test", "content":"Test"}' } catch { Write-Host "Erreur 404 attendue: $($_.Exception.Message)" }
```

## **14. Test d'erreur - Supprimer un article inexistant (DELETE)**
```powershell
try { Invoke-RestMethod -Uri "http://localhost:3000/api/articles/inexistant" -Method DELETE } catch { Write-Host "Erreur 404 attendue: $($_.Exception.Message)" }
```



## **üìã Instructions :**
1. Copiez et ex√©cutez les commandes **1, 2, 3** pour cr√©er 3 articles
2. Ex√©cutez la commande **4** pour voir tous les articles et **noter les IDs**
3. Remplacez `ARTICLE_ID_1`, `ARTICLE_ID_2`, `ARTICLE_ID_3` par les vrais IDs dans les commandes suivantes
4. Continuez avec les commandes **5 √† 14** dans l'ordre

## ** R√©sultats attendus :**
- **1-3** : Articles cr√©√©s avec les donn√©es compl√®tes
- **4** : Liste de 3 articles avec leurs IDs
- **5-6** : Articles individuels
- **7** : Article modifi√© avec nouvelles donn√©es
- **8** : Article avec les modifications visibles
- **9** : Article supprim√© confirm√©
- **10** : Liste de 2 articles (le 3√®me supprim√©)
- **11** : Message d'erreur 404
- **12-14** : Messages d'erreur 400 ou 404

## **üí° Avantages d'Invoke-RestMethod :**
- Pas de probl√®me d'√©chappement de guillemets
- R√©sultats automatiquement format√©s en JSON
- Gestion native des erreurs PowerShell
- Plus lisible et maintenable









## <span id="3.8">3.8 Commit attendu</span>

```bash
git add .
git commit -m "feat: complete CRUD for articles with in-memory store"
```



## <span id="3.9">3.9 Prochaine √©tape</span>

Dans le **Module 4**, nous allons :

* int√©grer une base de donn√©es r√©elle : **PostgreSQL**
* utiliser **Prisma** comme ORM
* remplacer le tableau `In-Memory` par une table r√©elle
* commencer √† construire des validations avanc√©es avec `zod`


<br/>

# Annexe 1 - R√©sum√© des codes √† ajouter



# <span id="module-3-tempstore">3. Persistance temporaire : In-Memory (CRUD articles)</span>



## <span id="3.1">3.1 Objectif du module</span>

Cr√©er un micro-service REST complet pour la gestion d‚Äôarticles sans base de donn√©es.
Ce module impl√©mente :

* un tableau en m√©moire (`In-Memory`)
* des identifiants g√©n√©r√©s automatiquement avec `uuid`
* une validation manuelle minimale
* des routes REST conformes aux standards HTTP (`GET`, `POST`, `PUT`, `DELETE`)



## <span id="3.2">3.2 Pr√©parer les fichiers</span>

### Organisation visuelle du projet

```
my-api-project/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ articles/
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ route.ts              ‚Üê pour GET (tous) et POST
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ [id]/                 ‚Üê dossier dynamique
‚îÇ   ‚îÇ               ‚îî‚îÄ‚îÄ route.ts          ‚Üê pour GET, PUT, DELETE par ID
‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ data.ts                       ‚Üê tableau d'articles en m√©moire
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.ts                      ‚Üê g√©n√©ration UUID
‚îÇ   ‚îî‚îÄ‚îÄ types/
‚îÇ       ‚îî‚îÄ‚îÄ article.ts                    ‚Üê structure TypeScript d‚Äôun article
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ .prettierrc.json
```



### Fichier `src/types/article.ts` ‚Äì D√©finition du type Article

```ts
export type Article = {
  id: string
  title: string
  content: string
  createdAt: string
}
```



### Fichier `src/lib/data.ts` ‚Äì Stockage temporaire en m√©moire

```ts
import { Article } from '@/types/article'

export const articles: Article[] = []
```


### Fichier `src/lib/utils.ts` ‚Äì G√©n√©ration d‚Äôidentifiants uniques

Installez la d√©pendance :

```bash
npm install uuid
```

Code du fichier :

```ts
import { v4 as uuidv4 } from 'uuid'

export function generateId() {
  return uuidv4()
}
```



## <span id="3.3">3.3 Route GET ‚Äì Liste de tous les articles</span>

Fichier : `src/app/api/articles/route.ts`

```ts
import { NextResponse } from 'next/server'
import { articles } from '@/lib/data'

export async function GET() {
  return NextResponse.json(articles)
}
```

Testez dans votre navigateur :

```
http://localhost:3000/api/articles
```


## <span id="3.4">3.4 Route POST ‚Äì Cr√©ation d‚Äôun article</span>

Toujours dans `src/app/api/articles/route.ts` :

```ts
import { generateId } from '@/lib/utils'

export async function POST(req: Request) {
  const body = await req.json()

  if (!body.title || !body.content) {
    return NextResponse.json({ error: 'Missing fields' }, { status: 400 })
  }

  const newArticle = {
    id: generateId(),
    title: body.title,
    content: body.content,
    createdAt: new Date().toISOString(),
  }

  articles.push(newArticle)

  return NextResponse.json(newArticle, { status: 201 })
}
```


### Test avec `curl`

```bash
curl -X POST http://localhost:3000/api/articles \
  -H "Content-Type: application/json" \
  -d '{"title":"Test", "content":"Ceci est un article."}'
```



## <span id="3.5">3.5 Routes dynamiques : GET, PUT, DELETE par `id`</span>

Fichier : `src/app/api/articles/[id]/route.ts`



### Route GET ‚Äì Lire un seul article

```ts
import { articles } from '@/lib/data'
import { NextResponse } from 'next/server'

export async function GET(_: Request, context: { params: { id: string } }) {
  const article = articles.find((a) => a.id === context.params.id)

  if (!article) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  return NextResponse.json(article)
}
```



### Route PUT ‚Äì Mettre √† jour un article

```ts
export async function PUT(req: Request, context: { params: { id: string } }) {
  const index = articles.findIndex((a) => a.id === context.params.id)

  if (index === -1) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  const body = await req.json()

  if (!body.title || !body.content) {
    return NextResponse.json({ error: 'Invalid payload' }, { status: 400 })
  }

  articles[index] = {
    ...articles[index],
    title: body.title,
    content: body.content,
  }

  return NextResponse.json(articles[index])
}
```



### Route DELETE ‚Äì Supprimer un article

```ts
export async function DELETE(_: Request, context: { params: { id: string } }) {
  const index = articles.findIndex((a) => a.id === context.params.id)

  if (index === -1) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  const deleted = articles.splice(index, 1)

  return NextResponse.json(deleted[0])
}
```



## <span id="3.6">3.6 Validation manuelle minimale</span>

Aucune librairie externe n‚Äôest utilis√©e √† ce stade.

Exemple de validation utilis√©e :

```ts
if (!body.title || !body.content) {
  return NextResponse.json({ error: 'Missing fields' }, { status: 400 })
}
```

Cela assure que les donn√©es obligatoires (`title`, `content`) sont bien pr√©sentes.

> Une validation plus stricte sera ajout√©e avec `zod` dans le Module 5.


## <span id="3.7">3.7 Tests √† effectuer</span>

|  M√©thode | URL                 | Attendu                        |
| -------: | ------------------- | ------------------------------ |
|   `POST` | `/api/articles`     | Cr√©e un nouvel article         |
|    `GET` | `/api/articles`     | Liste tous les articles        |
|    `GET` | `/api/articles/:id` | R√©cup√®re un article sp√©cifique |
|    `PUT` | `/api/articles/:id` | Met √† jour un article existant |
| `DELETE` | `/api/articles/:id` | Supprime un article            |

Checklist :

* [x] Cr√©er un article
* [x] Lire tous les articles
* [x] Lire un seul article
* [x] Modifier un article
* [x] Supprimer un article



## <span id="3.8">3.8 Commit attendu</span>

```bash
git add .
git commit -m "feat: complete CRUD for articles with in-memory store"
```


## <span id="3.9">3.9 Prochaine √©tape</span>

Dans le **Module 4**, nous allons :

* Remplacer le tableau en m√©moire par une base **PostgreSQL**
* Utiliser **Prisma** pour mod√©liser les donn√©es
* Connecter Prisma √† une base distante (Neon)
* Impl√©menter le m√™me CRUD, mais avec persistance r√©elle



<br />


# Annexe 1 - Description des routes


```
my-api-project/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ articles/
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ route.ts              ‚Üê pour GET (tous) et POST
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ [id]/                 ‚Üê dossier dynamique
‚îÇ   ‚îÇ               ‚îî‚îÄ‚îÄ route.ts          ‚Üê pour GET, PUT, DELETE par ID
‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ data.ts                       ‚Üê tableau d'articles en m√©moire
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.ts                      ‚Üê g√©n√©ration UUID
‚îÇ   ‚îî‚îÄ‚îÄ types/
‚îÇ       ‚îî‚îÄ‚îÄ article.ts                    ‚Üê structure TypeScript d‚Äôun article
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ .prettierrc.json
```



#### Partie 1  - Arbsresence 

```
my-api-project/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ articles/
‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ route.ts              ‚Üê pour GET (tous) et POST
#### Partie 2 - Code
```


#### Partie 1 - Code

```
import { NextResponse } from 'next/server'
import { articles } from '@/lib/data'
import { generateId } from '@/lib/utils'


export async function GET() {
  return NextResponse.json(articles)
}




export async function POST(req: Request) {
  const body = await req.json()

  if (!body.title || !body.content) {
    return NextResponse.json({ error: 'Missing fields' }, { status: 400 })
  }

  const newArticle = {
    id: generateId(),
    title: body.title,
    content: body.content,
    createdAt: new Date().toISOString(),
  }

  articles.push(newArticle)

  return NextResponse.json(newArticle, { status: 201 })
}

```







#### Partie 2  - Arbsresence 

```
‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ [id]/                 ‚Üê dossier dynamique
‚îÇ   ‚îÇ               ‚îî‚îÄ‚îÄ route.ts          ‚Üê pour GET, PUT, DELETE par ID
```





#### Partie 2  - Code


```
import { articles } from '@/lib/data'
import { NextResponse } from 'next/server'

// Route GET ‚Äì Lire un seul article
export async function GET(_: Request, context: { params: { id: string } }) {
  const article = articles.find((a) => a.id === context.params.id)

  if (!article) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  return NextResponse.json(article)
}

// Route PUT ‚Äì Mettre √† jour un article
export async function PUT(req: Request, context: { params: { id: string } }) {
  const index = articles.findIndex((a) => a.id === context.params.id)

  if (index === -1) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  const body = await req.json()

  if (!body.title || !body.content) {
    return NextResponse.json({ error: 'Invalid payload' }, { status: 400 })
  }

  articles[index] = {
    ...articles[index],
    title: body.title,
    content: body.content,
  }

  return NextResponse.json(articles[index])
}

// Route DELETE ‚Äì Supprimer un article
export async function DELETE(_: Request, context: { params: { id: string } }) {
  const index = articles.findIndex((a) => a.id === context.params.id)

  if (index === -1) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  const deleted = articles.splice(index, 1)

  return NextResponse.json(deleted[0])
} 
```


#### Partie 3  - Description

1.1. **Route principale** : `src/app/api/articles/route.ts`
   - Routes **GET** et **POST** pour la collection d'articles

1.2. **Nouvelles routes dynamiques** : `src/app/api/articles/[id]/route.ts`
   - Route **GET** `/api/articles/:id` - Lire un seul article
   - Route **PUT** `/api/articles/:id` - Mettre √† jour un article
   - Route **DELETE** `/api/articles/:id` - Supprimer un article

### ** Tests √† effectuer avec Postman :**

#### **1. Cr√©er un article (POST)**
```
POST http://localhost:3000/api/articles
Content-Type: application/json

{
  "title": "Mon premier article",
  "content": "Contenu de l'article"
}
```

#### **2. Lire tous les articles (GET)**
```
GET http://localhost:3000/api/articles
```

#### **3. Lire un seul article (GET)**
```
GET http://localhost:3000/api/articles/{id}
```
*(Remplacez `{id}` par l'ID d'un article existant)*

#### **4. Modifier un article (PUT)**
```
PUT http://localhost:3000/api/articles/{id}
Content-Type: application/json

{
  "title": "Titre modifi√©",
  "content": "Contenu modifi√©"
}
```

#### **5. Supprimer un article (DELETE)**
```
DELETE http://localhost:3000/api/articles/{id}
```

### **üîß Validation en place :**
- V√©rification que `title` et `content` sont pr√©sents
- Gestion des erreurs 404 (Article non trouv√©)
- Gestion des erreurs 400 (Donn√©es invalides)





<br />


---

# Annexe 2 - **Suite de tests CRUD avec Invoke-RestMethod - √Ä copier dans l'ordre**

## **1. Cr√©er le premier article (POST)**
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles" -Method POST -ContentType "application/json" -Body '{"title":"Premier Article", "content":"Contenu du premier article de test."}'
```

## **2. Cr√©er le deuxi√®me article (POST)**
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles" -Method POST -ContentType "application/json" -Body '{"title":"Deuxi√®me Article", "content":"Contenu du deuxi√®me article de test."}'
```

## **3. Cr√©er le troisi√®me article (POST)**
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles" -Method POST -ContentType "application/json" -Body '{"title":"Article √† supprimer", "content":"Cet article sera supprim√© plus tard."}'
```

## **4. Lire tous les articles (GET)**
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles" -Method GET
```

## **5. Lire le premier article par ID (GET)**
*Remplacez `ARTICLE_ID_1` par l'ID du premier article retourn√©*
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles/ARTICLE_ID_1" -Method GET
```

## **6. Lire le deuxi√®me article par ID (GET)**
*Remplacez `ARTICLE_ID_2` par l'ID du deuxi√®me article retourn√©*
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles/ARTICLE_ID_2" -Method GET
```

## **7. Modifier le premier article (PUT)**
*Remplacez `ARTICLE_ID_1` par l'ID du premier article*
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles/ARTICLE_ID_1" -Method PUT -ContentType "application/json" -Body '{"title":"Premier Article MODIFI√â", "content":"Contenu modifi√© du premier article."}'
```

## **8. V√©rifier la modification (GET)**
*Remplacez `ARTICLE_ID_1` par l'ID du premier article*
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles/ARTICLE_ID_1" -Method GET
```

## **9. Supprimer le troisi√®me article (DELETE)**
*Remplacez `ARTICLE_ID_3` par l'ID du troisi√®me article*
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles/ARTICLE_ID_3" -Method DELETE
```

## **10. V√©rifier la suppression - Lire tous les articles (GET)**
```powershell
Invoke-RestMethod -Uri "http://localhost:3000/api/articles" -Method GET
```

## **11. Essayer de lire l'article supprim√© (doit retourner 404)**
*Remplacez `ARTICLE_ID_3` par l'ID de l'article supprim√©*
```powershell
try { Invoke-RestMethod -Uri "http://localhost:3000/api/articles/ARTICLE_ID_3" -Method GET } catch { Write-Host "Erreur 404 attendue: $($_.Exception.Message)" }
```

## **12. Test d'erreur - Cr√©er un article invalide (POST)**
```powershell
try { Invoke-RestMethod -Uri "http://localhost:3000/api/articles" -Method POST -ContentType "application/json" -Body '{"title":""}' } catch { Write-Host "Erreur 400 attendue: $($_.Exception.Message)" }
```

## **13. Test d'erreur - Modifier un article inexistant (PUT)**
```powershell
try { Invoke-RestMethod -Uri "http://localhost:3000/api/articles/inexistant" -Method PUT -ContentType "application/json" -Body '{"title":"Test", "content":"Test"}' } catch { Write-Host "Erreur 404 attendue: $($_.Exception.Message)" }
```

## **14. Test d'erreur - Supprimer un article inexistant (DELETE)**
```powershell
try { Invoke-RestMethod -Uri "http://localhost:3000/api/articles/inexistant" -Method DELETE } catch { Write-Host "Erreur 404 attendue: $($_.Exception.Message)" }
```



## **Instructions :**
1. Copiez et ex√©cutez les commandes **1, 2, 3** pour cr√©er 3 articles
2. Ex√©cutez la commande **4** pour voir tous les articles et **noter les IDs**
3. Remplacez `ARTICLE_ID_1`, `ARTICLE_ID_2`, `ARTICLE_ID_3` par les vrais IDs dans les commandes suivantes
4. Continuez avec les commandes **5 √† 14** dans l'ordre

## **‚úÖ R√©sultats attendus :**
- **1-3** : Articles cr√©√©s avec les donn√©es compl√®tes
- **4** : Liste de 3 articles avec leurs IDs
- **5-6** : Articles individuels
- **7** : Article modifi√© avec nouvelles donn√©es
- **8** : Article avec les modifications visibles
- **9** : Article supprim√© confirm√©
- **10** : Liste de 2 articles (le 3√®me supprim√©)
- **11** : Message d'erreur 404
- **12-14** : Messages d'erreur 400 ou 404

## **üí° Avantages d'Invoke-RestMethod :**
- Pas de probl√®me d'√©chappement de guillemets
- R√©sultats automatiquement format√©s en JSON
- Gestion native des erreurs PowerShell
- Plus lisible et maintenable




<br />

---

# Annexe 3 - Est-ce que je dois les deux fichiers route.ts ?



## R√©posne : **OUI, vous devez absolument GARDER ce `route.ts` !**

Ce fichier est **ESSENTIEL** et fonctionne parfaitement avec votre setup. Voici pourquoi :

### **Structure actuelle :**
```
src/app/api/articles/
‚îú‚îÄ‚îÄ route.ts              ‚Üê GARDEZ-LE ! (Routes de collection)
‚îî‚îÄ‚îÄ [id]/
    ‚îî‚îÄ‚îÄ route.ts          ‚Üê Nouveau fichier (Routes individuelles)
```

### **R√©partition des responsabilit√©s :**

#### **`/api/articles/route.ts`** (Collection)
- **GET** `/api/articles` ‚Üí Lire **TOUS** les articles
- **POST** `/api/articles` ‚Üí Cr√©er un **NOUVEL** article

#### **`/api/articles/[id]/route.ts`** (√âl√©ment individuel)  
- **GET** `/api/articles/:id` ‚Üí Lire **UN** article
- **PUT** `/api/articles/:id` ‚Üí Modifier **UN** article  
- **DELETE** `/api/articles/:id` ‚Üí Supprimer **UN** article

### ** Pourquoi √ßa fonctionne parfaitement :**

1. **S√©paration logique** : Collection vs √âl√©ment individuel
2. **Standard REST** : C'est exactement comme √ßa qu'on fait du CRUD
3. **Next.js App Router** : Supporte parfaitement cette structure
4. **Pas de conflit** : Les routes sont sur des paths diff√©rents

### **‚úÖ CRUD complet :**
```
GET    /api/articles     ‚Üí Tous les articles      (route.ts)
POST   /api/articles     ‚Üí Cr√©er article          (route.ts)
GET    /api/articles/123 ‚Üí Article par ID         ([id]/route.ts)
PUT    /api/articles/123 ‚Üí Modifier article       ([id]/route.ts)
DELETE /api/articles/123 ‚Üí Supprimer article      ([id]/route.ts)
```

### **‚ö†Ô∏è SI vous supprimez `route.ts` :**
- ‚ùå Plus de `GET /api/articles` (lire tous)
- ‚ùå Plus de `POST /api/articles` (cr√©er nouveau)
- ‚ùå API incompl√®te

## Il faut GARDEZ les deux fichiers route.ts !**

Notre structure est **parfaite** et respecte les bonnes pratiques REST. Les deux fichiers travaillent ensemble pour former une API CRUD compl√®te.
