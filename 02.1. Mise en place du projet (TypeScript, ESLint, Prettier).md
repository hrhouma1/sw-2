# <span id="module-2-setup">2. Mise en place du projet (TypeScript, ESLint, Prettier)</span>


## <span id="2.1">2.1 Objectif du module</span>

Préparer un socle technique robuste pour développer un service web REST avec Next.js 15 (App Router).
Ce module pose les fondations suivantes :

* Utilisation de **TypeScript** pour le typage strict
* Mise en place de **l’App Router** (architecture `/app`)
* Installation des outils de qualité de code (**ESLint**, **Prettier**)
* Nettoyage de l’arborescence par défaut
* Création d’un point d’entrée pour les routes API
* Préparation d’un **micro-service de gestion d’articles**



## <span id="2.2">2.2 Création initiale du projet</span>

Lancer la création du projet avec les options attendues :

```bash
npx create-next-app@latest my-api-project --typescript
```

Répondez comme suit :

```
✔ Would you like to use TypeScript?              › Yes
✔ Would you like to use ESLint?                  › Yes
✔ Would you like to use Tailwind CSS?            › No
✔ Would you like to use `src/` directory?        › Yes
✔ Would you like to use App Router?              › Yes
✔ Would you like to customize the default alias? › No
```

Démarrer le projet :

```bash
cd my-api-project
npm run dev
```

Accéder à [http://localhost:3000](http://localhost:3000)



## <span id="2.3">2.3 Nettoyage de l’arborescence</span>

Supprimez les éléments inutiles pour une API pure :

```bash
rm -rf src/app/page.tsx
rm -rf src/app/globals.css
rm -rf public/vercel.svg
```

Nous ne faisons pas de frontend dans ce module. Seules les routes API seront utilisées.

Créer le dossier de routes API :

```bash
mkdir -p src/app/api/articles
```



## <span id="2.4">2.4 Installation des outils qualité de code</span>

Installer les dépendances de développement :

```bash
npm install -D eslint prettier eslint-plugin-import eslint-config-prettier
```

Créer le fichier de configuration Prettier :

```bash
touch .prettierrc.json
```

Contenu du fichier `.prettierrc.json` :

```json
{
  "semi": false,
  "singleQuote": true,
  "trailingComma": "es5"
}
```

Modifier le bloc `scripts` dans `package.json` pour ajouter :

```json
"scripts": {
  "dev": "next dev",
  "build": "next build",
  "start": "next start",
  "lint": "eslint . --ext .ts,.tsx",
  "format": "prettier --write ."
}
```

Lancer les vérifications :

```bash
npm run lint
npm run format
```



## <span id="2.5">2.5 Structuration professionnelle du projet</span>

Voici la structure cible recommandée :

```
src/
├── app/                    ← App Router
│   └── api/                ← API REST endpoints
│       └── articles/       ← CRUD pour les articles
│           └── route.ts    ← fichier d'entrée de l’API
│
├── lib/                    ← logique applicative, accès aux données
│   └── data.ts             ← tableau mémoire temporaire
│
├── types/                  ← définitions TypeScript
│   └── article.ts
```

Diagramme ASCII :

```
my-api-project/
├── .prettierrc.json
├── package.json
├── tsconfig.json
├── src/
│   ├── app/
│   │   └── api/
│   │       └── articles/
│   │           └── route.ts
│   ├── lib/
│   │   └── data.ts
│   └── types/
│       └── article.ts
```



## <span id="2.6">2.6 Projet concret : service d’articles</span>

L’objectif est de créer un **mini backend REST** capable de :

* Créer un article (`POST`)
* Lire tous les articles (`GET`)
* Lire un seul article (`GET /:id`)
* Modifier un article (`PUT`)
* Supprimer un article (`DELETE`)

À ce stade, les données sont maintenues en mémoire (sans base de données).



## <span id="2.7">2.7 Définir la structure de données</span>

Créer le fichier `src/types/article.ts` :

```ts
export type Article = {
  id: string
  title: string
  content: string
  createdAt: string
}
```

Créer le fichier `src/lib/data.ts` :

```ts
import { Article } from '@/types/article'

export const articles: Article[] = []
```

> Ce tableau servira d’**In-Memory Store** pour simuler une base de données temporaire.



## <span id="2.8">2.8 Test de la première route API</span>

Créer un fichier de test dans `src/app/api/articles/route.ts` :

```ts
// src/app/api/articles/route.ts
import { NextResponse } from 'next/server'

export async function GET() {
  return NextResponse.json({ status: 'API OK' })
}
```

Accéder à :

```
http://localhost:3000/api/articles
```

Réponse attendue :

```json
{
  "status": "API OK"
}
```



### Commit Git attendu

```bash
git add .
git commit -m "chore: setup project structure and dummy API route"
```



## <span id="2.9">2.9 Prochaine étape</span>

Dans le **Module 3**, vous implémenterez un vrai service CRUD complet sur les articles :

* avec génération d’identifiants,
* validation manuelle (pas encore de schéma Zod),
* gestion des erreurs HTTP,
* puis dans un second temps, intégration de Prisma + PostgreSQL.


<br/>

# Annexe 1 - Outils de qualité de code


L’outil **ESLint** joue un rôle fondamental dans la qualité et la stabilité du code JavaScript et TypeScript, en assurant une **vérification statique** des fichiers sources. Concrètement, ESLint lit le code ligne par ligne et signale toute erreur de syntaxe, incohérence de style, oubli de type ou pratique risquée avant même l’exécution. Dans le cadre d’un projet Next.js avec TypeScript, cette vérification est particulièrement utile car elle permet de garantir que tous les fichiers respectent les conventions de codage, utilisent les types correctement, et ne laissent pas passer des oublis fréquents comme des variables inutilisées, des fonctions non typées ou des imports obsolètes. Cela améliore immédiatement la lisibilité, la maintenabilité et la fiabilité du code, surtout dans une architecture en App Router où plusieurs développeurs peuvent intervenir sur des routes, des composants, ou des services backend.

L’ajout d’ESLint dès la création du projet permet aussi de définir une **culture de qualité de code partagée**, avec des règles personnalisables et centralisées dans un fichier de configuration (`.eslintrc`, ou via les plugins et presets comme `eslint-config-prettier`). Il s’intègre parfaitement dans les scripts de développement (`npm run lint`), dans les IDE comme VS Code, et dans les pipelines CI/CD, pour bloquer des commits ou des déploiements non conformes. Couplé à **Prettier**, ESLint permet non seulement de détecter les erreurs, mais aussi de garantir un formatage homogène (espaces, guillemets, virgules, etc.) sur l’ensemble du projet, sans débat de style. Dans le contexte d’un service web structuré en REST avec gestion des routes API (`/api/articles`), c’est une base technique indispensable pour éviter les erreurs silencieuses et produire un code propre, validé automatiquement à chaque itération.


<br/>




